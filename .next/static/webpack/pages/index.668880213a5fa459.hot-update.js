"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Cell.js":
/*!****************************!*\
  !*** ./components/Cell.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _styles_game_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/game.module.css */ \"./styles/game.module.css\");\n/* harmony import */ var _styles_game_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_game_module_css__WEBPACK_IMPORTED_MODULE_2__);\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\nvar _this = undefined;\nvar _s = $RefreshSig$();\nvar colors = [\n    \"gold\",\n    \"violet\",\n    \"springgreen\",\n    \"tomato\",\n    \"lightskyblue\"\n];\nvar Cell = function(props) {\n    _s();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), checked = ref[0], setChecked = ref[1];\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), type = ref1[0], setType = ref1[1];\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), flag = ref2[0], setFlag = ref2[1];\n    var ref3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n    }), hiddenStyle = ref3[0], setHiddenStyle = ref3[1];\n    var ref4 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n    }), checkedStyle = ref4[0], setCheckedStyle = ref4[1];\n    // When the game num changes, go ahead and rerender this cell\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        // based on props.gameNum, we do things diff\n        // let index = props.gameNum % 5; // if i want to change the color\n        var index = 0;\n        var hStyle = {\n            border: \"1px solid \".concat(colors[index]),\n            color: colors[index]\n        };\n        var cStyle = {\n            border: \"1px solid \".concat(colors[index]),\n            color: colors[index],\n            background: props.type === \"x\" ? \"red\" : \"rgba(255, 217, 0, 0.171)\"\n        };\n        setType(props.type);\n        setChecked(false);\n        setFlag(false);\n        setHiddenStyle(hStyle);\n        setCheckedStyle(cStyle);\n    }, [\n        props.gameNum\n    ]);\n    var cellClick = function() {\n        if (checked) return;\n        else if (type === \"x\") props.endGame(false);\n        else {\n            // x is column, y is row\n            var x = props.x, y = props.y;\n            var mineNum = 0;\n            // 0   1   2\n            // o | o | o  0\n            // x | o | x  1\n            // o | x | o  2\n            // Current Coord: (1,1)\n            // use our cells current coordinate and add it to\n            // our for loops to check the surrounding cells\n            for(var row = -1; row <= 1; row++){\n                for(var col = -1; col <= 1; col++){\n                    if (row === 0 && col === 0) continue; // dont check current cell\n                    if (y + row < 0 || y + row >= props.board.length) continue; // dont check y out of bounds\n                    if (x + col < 0 || x + col >= props.board[0].length) continue; // dont check x out of bounds\n                    var thisCell = props.board[y + row][x + col]; // get the value at this coordinate\n                    if (thisCell === \"x\") mineNum++; // if this cell has a mine, add to num\n                }\n            }\n            // This works as long as were in the center somewhat\n            // Dependent on y! Make this better later forsure bb\n            // only do this if number of mines is 0\n            if (mineNum === 0) {\n                var _loop1 = function(row1) {\n                    var _loop = function(col) {\n                        if (row1 === 0 && col === 0) return \"continue\" // dont check the current cell dummy\n                        ;\n                        if (y + row1 < 0 || y + row1 >= props.board.length) return \"continue\";\n                        if (x + col < 0 || x + col >= props.board[0].length) return \"continue\";\n                        // let index = parseInt(`${y + row}${x + col}`);\n                        // if (index < 0 || index >= cells.length) continue;\n                        var cellY = y + row1;\n                        var cellX = x + col;\n                        var surroundingCell = document.getElementById(\"\".concat(cellY, \"-\").concat(cellX)); // we have the cell, now get reference from board\n                        // Later on, implement a function that makes this a timed event\n                        var time = Math.floor(Math.random() * 150) + 100;\n                        setTimeout(function() {\n                            return surroundingCell.click();\n                        }, time);\n                    };\n                    for(var col = -1; col <= 1; col++){\n                        var _ret = _loop(col);\n                        if (_ret === \"continue\") return \"continue\";\n                    }\n                };\n                // we only click since all other cells not be mines\n                // dont have to do the above code anymore\n                // Should we split up cells based on our board array?\n                // Check surrounding cells\n                // what is x and y?\n                for(var row1 = -1; row1 <= 1; row1++){\n                    var _ret1 = _loop1(row1);\n                    if (_ret1 === \"continue\") continue;\n                }\n            }\n            var copyBoard = props.board.slice(); // get our current board\n            copyBoard[y][x] = mineNum;\n            props.setBoard(copyBoard);\n            // You win!\n            if (props.checkWin(copyBoard)) {\n                props.endGame(true);\n            }\n            if (mineNum === 0) {\n                setType(\"\");\n            } else {\n                setType(mineNum);\n            }\n        }\n        setChecked(true); // this will re-render the cell\n    };\n    var putFlagDown = function(event) {\n        event.preventDefault();\n        if (!checked) setFlag(!flag);\n    };\n    // y is row\n    // x is col\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: flag ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            id: \"\".concat(props.y, \"-\").concat(props.x),\n            className: (_styles_game_module_css__WEBPACK_IMPORTED_MODULE_2___default().cell),\n            style: hiddenStyle,\n            onContextMenu: function(e) {\n                return putFlagDown(e);\n            },\n            __source: {\n                fileName: \"C:\\\\Users\\\\danie\\\\Code\\\\minesweeper\\\\components\\\\Cell.js\",\n                lineNumber: 116,\n                columnNumber: 17\n            },\n            __self: _this,\n            children: \"?\"\n        }) : /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            id: \"\".concat(props.y, \"-\").concat(props.x),\n            className: (_styles_game_module_css__WEBPACK_IMPORTED_MODULE_2___default().cell),\n            onClick: cellClick,\n            onContextMenu: function(e) {\n                return putFlagDown(e);\n            },\n            style: checked ? checkedStyle : hiddenStyle,\n            __source: {\n                fileName: \"C:\\\\Users\\\\danie\\\\Code\\\\minesweeper\\\\components\\\\Cell.js\",\n                lineNumber: 125,\n                columnNumber: 17\n            },\n            __self: _this,\n            children: checked ? type : \" \"\n        })\n    }));\n};\n_s(Cell, \"RGpRmqALLD4M3f5XKPWceZnKc+E=\");\n_c = Cell;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cell);\nvar _c;\n$RefreshReg$(_c, \"Cell\");\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFakQsT0FBTyxHQUFHUSxZQUFZLEdBQUdGLFdBQVc7Ozs7Ozs7c0JBRTFDTixPQUFPLEdBQUdFLElBQUksR0FBRyxDQUFHOzs7QUFLekMsQ0FBQztHQW5JS0osSUFBSTtLQUFKQSxJQUFJO0FBcUlWLCtEQUFlQSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2VsbC5qcz9mZGNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi4vc3R5bGVzL2dhbWUubW9kdWxlLmNzcydcclxuXHJcbmNvbnN0IGNvbG9ycyA9IFtcImdvbGRcIiwgXCJ2aW9sZXRcIiwgXCJzcHJpbmdncmVlblwiLCBcInRvbWF0b1wiLCBcImxpZ2h0c2t5Ymx1ZVwiXTtcclxuXHJcbmNvbnN0IENlbGwgPSAocHJvcHMpID0+IHtcclxuICAgIGxldCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBsZXQgW3R5cGUsIHNldFR5cGVdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgICBsZXQgW2ZsYWcsIHNldEZsYWddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgbGV0IFtoaWRkZW5TdHlsZSwgc2V0SGlkZGVuU3R5bGVdID0gdXNlU3RhdGUoe30pO1xyXG4gICAgbGV0IFtjaGVja2VkU3R5bGUsIHNldENoZWNrZWRTdHlsZV0gPSB1c2VTdGF0ZSh7fSk7XHJcblxyXG4gICAgLy8gV2hlbiB0aGUgZ2FtZSBudW0gY2hhbmdlcywgZ28gYWhlYWQgYW5kIHJlcmVuZGVyIHRoaXMgY2VsbFxyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgLy8gYmFzZWQgb24gcHJvcHMuZ2FtZU51bSwgd2UgZG8gdGhpbmdzIGRpZmZcclxuICAgICAgICAvLyBsZXQgaW5kZXggPSBwcm9wcy5nYW1lTnVtICUgNTsgLy8gaWYgaSB3YW50IHRvIGNoYW5nZSB0aGUgY29sb3JcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGxldCBoU3R5bGUgPSB7XHJcbiAgICAgICAgICAgIGJvcmRlcjogYDFweCBzb2xpZCAke2NvbG9yc1tpbmRleF19YCxcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tpbmRleF0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgY1N0eWxlID0ge1xyXG4gICAgICAgICAgICBib3JkZXI6IGAxcHggc29saWQgJHtjb2xvcnNbaW5kZXhdfWAsXHJcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcnNbaW5kZXhdLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBwcm9wcy50eXBlID09PSBcInhcIiA/IFwicmVkXCIgOiBcInJnYmEoMjU1LCAyMTcsIDAsIDAuMTcxKVwiLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2V0VHlwZShwcm9wcy50eXBlKTtcclxuICAgICAgICBzZXRDaGVja2VkKGZhbHNlKTtcclxuICAgICAgICBzZXRGbGFnKGZhbHNlKTtcclxuICAgICAgICBzZXRIaWRkZW5TdHlsZShoU3R5bGUpO1xyXG4gICAgICAgIHNldENoZWNrZWRTdHlsZShjU3R5bGUpO1xyXG4gICAgfSwgW3Byb3BzLmdhbWVOdW1dKTtcclxuXHJcbiAgICBsZXQgY2VsbENsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChjaGVja2VkKSByZXR1cm47XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJ4XCIpIHByb3BzLmVuZEdhbWUoZmFsc2UpO1xyXG4gICAgICAgIC8vIGlmIGNlbGwgaXMgJ3gnLCBnYW1lIGlzIG92ZXIhXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHggaXMgY29sdW1uLCB5IGlzIHJvd1xyXG4gICAgICAgICAgICBsZXQgeyB4LCB5IH0gPSBwcm9wcztcclxuICAgICAgICAgICAgbGV0IG1pbmVOdW0gPSAwO1xyXG4gICAgICAgICAgICAvLyAwICAgMSAgIDJcclxuICAgICAgICAgICAgLy8gbyB8IG8gfCBvICAwXHJcbiAgICAgICAgICAgIC8vIHggfCBvIHwgeCAgMVxyXG4gICAgICAgICAgICAvLyBvIHwgeCB8IG8gIDJcclxuICAgICAgICAgICAgLy8gQ3VycmVudCBDb29yZDogKDEsMSlcclxuICAgICAgICAgICAgLy8gdXNlIG91ciBjZWxscyBjdXJyZW50IGNvb3JkaW5hdGUgYW5kIGFkZCBpdCB0b1xyXG4gICAgICAgICAgICAvLyBvdXIgZm9yIGxvb3BzIHRvIGNoZWNrIHRoZSBzdXJyb3VuZGluZyBjZWxsc1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gLTE7IHJvdyA8PSAxOyByb3crKykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gLTE7IGNvbCA8PSAxOyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cgPT09IDAgJiYgY29sID09PSAwKSBjb250aW51ZTsgLy8gZG9udCBjaGVjayBjdXJyZW50IGNlbGxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeSArIHJvdyA8IDAgfHwgeSArIHJvdyA+PSBwcm9wcy5ib2FyZC5sZW5ndGgpIGNvbnRpbnVlOyAvLyBkb250IGNoZWNrIHkgb3V0IG9mIGJvdW5kc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICsgY29sIDwgMCB8fCB4ICsgY29sID49IHByb3BzLmJvYXJkWzBdLmxlbmd0aCkgY29udGludWU7IC8vIGRvbnQgY2hlY2sgeCBvdXQgb2YgYm91bmRzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRoaXNDZWxsID0gcHJvcHMuYm9hcmRbeSArIHJvd11beCArIGNvbF07IC8vIGdldCB0aGUgdmFsdWUgYXQgdGhpcyBjb29yZGluYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNDZWxsID09PSBcInhcIikgbWluZU51bSsrOyAvLyBpZiB0aGlzIGNlbGwgaGFzIGEgbWluZSwgYWRkIHRvIG51bVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUaGlzIHdvcmtzIGFzIGxvbmcgYXMgd2VyZSBpbiB0aGUgY2VudGVyIHNvbWV3aGF0XHJcbiAgICAgICAgICAgIC8vIERlcGVuZGVudCBvbiB5ISBNYWtlIHRoaXMgYmV0dGVyIGxhdGVyIGZvcnN1cmUgYmJcclxuXHJcbiAgICAgICAgICAgIC8vIG9ubHkgZG8gdGhpcyBpZiBudW1iZXIgb2YgbWluZXMgaXMgMFxyXG4gICAgICAgICAgICBpZiAobWluZU51bSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gd2Ugb25seSBjbGljayBzaW5jZSBhbGwgb3RoZXIgY2VsbHMgbm90IGJlIG1pbmVzXHJcbiAgICAgICAgICAgICAgICAvLyBkb250IGhhdmUgdG8gZG8gdGhlIGFib3ZlIGNvZGUgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIHdlIHNwbGl0IHVwIGNlbGxzIGJhc2VkIG9uIG91ciBib2FyZCBhcnJheT9cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHN1cnJvdW5kaW5nIGNlbGxzXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gd2hhdCBpcyB4IGFuZCB5P1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gLTE7IHJvdyA8PSAxOyByb3crKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IC0xOyBjb2wgPD0gMTsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdyA9PT0gMCAmJiBjb2wgPT09IDApIGNvbnRpbnVlOyAvLyBkb250IGNoZWNrIHRoZSBjdXJyZW50IGNlbGwgZHVtbXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkgKyByb3cgPCAwIHx8IHkgKyByb3cgPj0gcHJvcHMuYm9hcmQubGVuZ3RoKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggKyBjb2wgPCAwIHx8IHggKyBjb2wgPj0gcHJvcHMuYm9hcmRbMF0ubGVuZ3RoKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGluZGV4ID0gcGFyc2VJbnQoYCR7eSArIHJvd30ke3ggKyBjb2x9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gY2VsbHMubGVuZ3RoKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGxZID0geSArIHJvdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGxYID0geCArIGNvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1cnJvdW5kaW5nQ2VsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGAke2NlbGxZfS0ke2NlbGxYfWApOyAvLyB3ZSBoYXZlIHRoZSBjZWxsLCBub3cgZ2V0IHJlZmVyZW5jZSBmcm9tIGJvYXJkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhdGVyIG9uLCBpbXBsZW1lbnQgYSBmdW5jdGlvbiB0aGF0IG1ha2VzIHRoaXMgYSB0aW1lZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGltZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE1MCkgKyAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc3Vycm91bmRpbmdDZWxsLmNsaWNrKCksIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGNvcHlCb2FyZCA9IHByb3BzLmJvYXJkLnNsaWNlKCk7IC8vIGdldCBvdXIgY3VycmVudCBib2FyZFxyXG4gICAgICAgICAgICBjb3B5Qm9hcmRbeV1beF0gPSBtaW5lTnVtO1xyXG4gICAgICAgICAgICBwcm9wcy5zZXRCb2FyZChjb3B5Qm9hcmQpO1xyXG5cclxuICAgICAgICAgICAgLy8gWW91IHdpbiFcclxuICAgICAgICAgICAgaWYgKHByb3BzLmNoZWNrV2luKGNvcHlCb2FyZCkpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmVuZEdhbWUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChtaW5lTnVtID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUeXBlKFwiXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0VHlwZShtaW5lTnVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRDaGVja2VkKHRydWUpOyAvLyB0aGlzIHdpbGwgcmUtcmVuZGVyIHRoZSBjZWxsXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBwdXRGbGFnRG93biA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgaWYgKCFjaGVja2VkKSBzZXRGbGFnKCFmbGFnKTtcclxuICAgIH07XHJcbiAgICAvLyB5IGlzIHJvd1xyXG4gICAgLy8geCBpcyBjb2xcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAge2ZsYWcgPyAoXHJcbiAgICAgICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgaWQ9e2Ake3Byb3BzLnl9LSR7cHJvcHMueH1gfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNlbGx9XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e2hpZGRlblN0eWxlfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ29udGV4dE1lbnU9eyhlKSA9PiBwdXRGbGFnRG93bihlKX1cclxuICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA/XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgICAgICBpZD17YCR7cHJvcHMueX0tJHtwcm9wcy54fWB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuY2VsbH1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtjZWxsQ2xpY2t9XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db250ZXh0TWVudT17KGUpID0+IHB1dEZsYWdEb3duKGUpfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtjaGVja2VkID8gY2hlY2tlZFN0eWxlIDogaGlkZGVuU3R5bGV9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge2NoZWNrZWQgPyB0eXBlIDogXCIgXCJ9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgKX1cclxuICAgICAgICA8Lz5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDZWxsIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJzdHlsZXMiLCJjb2xvcnMiLCJDZWxsIiwicHJvcHMiLCJjaGVja2VkIiwic2V0Q2hlY2tlZCIsInR5cGUiLCJzZXRUeXBlIiwiZmxhZyIsInNldEZsYWciLCJoaWRkZW5TdHlsZSIsInNldEhpZGRlblN0eWxlIiwiY2hlY2tlZFN0eWxlIiwic2V0Q2hlY2tlZFN0eWxlIiwiaW5kZXgiLCJoU3R5bGUiLCJib3JkZXIiLCJjb2xvciIsImNTdHlsZSIsImJhY2tncm91bmQiLCJnYW1lTnVtIiwiY2VsbENsaWNrIiwiZW5kR2FtZSIsIngiLCJ5IiwibWluZU51bSIsInJvdyIsImNvbCIsImJvYXJkIiwibGVuZ3RoIiwidGhpc0NlbGwiLCJjZWxsWSIsImNlbGxYIiwic3Vycm91bmRpbmdDZWxsIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInRpbWUiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJzZXRUaW1lb3V0IiwiY2xpY2siLCJjb3B5Qm9hcmQiLCJzbGljZSIsInNldEJvYXJkIiwiY2hlY2tXaW4iLCJwdXRGbGFnRG93biIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJkaXYiLCJpZCIsImNsYXNzTmFtZSIsImNlbGwiLCJzdHlsZSIsIm9uQ29udGV4dE1lbnUiLCJlIiwib25DbGljayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Cell.js\n");

/***/ })

});